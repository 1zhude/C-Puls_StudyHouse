# 第八章 函数探幽
## 1.内联函数
&emsp;&emsp;1.内联函数主要式编译器将`函数调用`改为`使用函数定义替换`;编译器使用相应的函数代码替换函数调用;
&emsp;&emsp;2.如果`执行代码的时间`比`函数调用`机制的时间长,则节省的时间只占整个过程的很小一部分。如果代码执行时间很短，则内联比函数调用节省很大的时间；
&emsp;&emsp;3.使用方法：
`a.在函数定义前增加关键字inline`
`b.在函数声明之前加关键字inline`
&emsp;&emsp;4.内联函数不支持的情况
`a.若函数过大，编译器可能不会支持内联函数的申请；`
`b.内联函数不能进行递归`
&emsp;&emsp;5.内联与宏
`宏`：主要是通过文本替换实现的;
`内联函数`：的调用是`按值传递`;

## 2.引用
&emsp;&emsp;1.C++新增了一种`复合类型`——引用变量，引用时已定义变量的别名；
&emsp;&emsp;2.引用格式：
```c
int rats;
int & rodents = rats;// rodents 是一个指向int &（rats）的引用；
```
&emsp;&emsp;3.在声明引用变量时必须进行初始化；并且一旦与某个变量关联起来，就一直效忠于它。
&emsp;&emsp;4.将引用作为参数传递进函数时，是按`引用传递`可改变原始数据内容；
&emsp;&emsp;5.C++生成临时变量
如果引用参数是const,则编译器将在下面两种情况下生成临时变量：
`1.实参的类型正确 但不是左值`
`2.实参类型不正确，但是可以转换成正确的类型`
> 左值：可被引用的数据对象；
 &emsp;&emsp;6.对于形参为const引用的C++函数，如果实参不匹配，则其行为类似于按值传递，为确保原始数据不被修改，将使用临时变量存储值；
&emsp;&emsp;`&&`右值引用
&emsp;&emsp;函数返回`引用`实际是返回被引用变量的别名。
## 3.继承
&emsp;&emsp;使得能够将特性从一个类传递给另一个类的语言特性被称为继承；
&emsp;&emsp;基类引用可以指向派生类对象，无需进行强制转换；

## 4.函数重载 
&emsp;&emsp;1.函数特征标：两个函数的参数数目和类型相同，同时参数排列顺序也相同,而变量名是无关紧要的;
&emsp;&emsp;2.编译器在检查特征标的时候，将类型引用和类型本身视为同一个特征标；
&emsp;&emsp;3.将非const值赋给const变量是合法的，但是反之则是非法的；
&emsp;&emsp;4.函数重载用于函数基本执行相同任务，但使用不同形式的数据时；
&emsp;&emsp;5.名称修饰/名称矫正：根据函数原型中指定的形参类型对每个函数名进行加密。

## 5.函数模板
&emsp;&emsp;1.函数模板是通用的函数描述,它们使用泛型来定义函数，其中可用具体的类型替换；
&emsp;&emsp;2.函数模板格式：
```c
template<typename T>
void Swap(T &a, T &b)
{

}
```
&emsp;&emsp;3.模板函数也可以根据不同的特征标进行模板重载；
&emsp;&emsp;4.并非所有的模板参数都必须是模板参数类型；
&emsp;&emsp;5.模板函数`显示具体化`
```c
// 以下两种均可
template <> void swap <job>(job &j1, job &j2)// 1
template <> void swap (job &j1, job &j2)// 2
```
&emsp;&emsp;5.模板函数`显示实例化`
```c
template void swap <job>(job &j1, job &j2)
```
>> `显式实例化`不需要写函数的具体实现，而`显式具体化`必须要；
&emsp;&emsp;重载解析
`a.创建候选函数列表`
`b.使用候选函数列表创建可行函数列表`
`c.确认是否有最佳可行函数`
&emsp;&emsp;最佳可行函数排序
`1、完全匹配`
`2、整型提升`
`3、标准转换`
`4、用户自定义转换`
`5、若只有一个函数匹配则选择该函数，若有非模板函数和模板函数均匹配，则选择非模板函数，若存在多个非模板函数匹配，则选择更“具体化”的函数`
&emsp;&emsp;有多个参数的函数调用与有多个参数原型进行匹配时，最佳函数应所有参数的匹配程度都必须不比其他函数差，同时至少有一个参数匹配程度更高；

## 模板函数的发展
&emsp;&emsp;1.关键字`decltype`
&emsp;&emsp;2.后置函数声明
```c 
template <typename T1, typename T2> 
auto gt(T1 x, T2 y) ——> decltype(x + y)
{
    .....
    return x + y;
}
```

# 第九章 内存模型和名称空间
## 多文件编译
&emsp;&emsp;1.C++开发过程中建议将函数、变量依据其不同功能模块，分别存储在不同的源代码中，在编译阶段对不同文件分别编译，形成中间文件，最后再由编译器统一链接成可执行文件；
通常这些源代码分成三类：一类是以`.h`文件作为后缀的`头文件`,通常包含定义的各种结构、类和函数原型；
另一类主要是`.cpp`作为后置的`源文件`，主要功能是为了实现`.h`文件中定义的各种函数原型以及相关代码；
最后一类也是`.cpp`结尾的文件，即为实现主要功能的程序，通常`main`单独定义在该文件中；
&emsp;&emsp;2.不要将函数定义（除内联函数外）和变量声明放在头文件中；
&emsp;&emsp;3.头文件常包含内容：函数原型、使用#define或const定义的符号常量、结构声明、类声明、模板声明、内联函数；
## 存储持续性、作用域和链接性
&emsp;四种存储数据的方案
&emsp;&emsp;1.自动存储的连续性：在函数定义中声明的变量（包含函数参数）存储性为自动的。在程序开始时执行其所属函数的代码块被创建，在执行完函数或代码块时，它们使用的内存被释放。C++有两种存储持续性为自动的变量；
&emsp;&emsp;2.静态储存的持续性：在函数定义外定义的变量和使用关键字static定义的变量存储持续性为静态。它们在程序的整个运行过程中都存在。C++有三种存储为静态的变量。
&emsp;&emsp;3.线程存储持续性（C++11）:关键字`thread_local`声明的变量，其生命周期与所属线程一样长。
&emsp;&emsp;4.动态储存持续性：用`new`分配的内存将一直存在，直到用`delete`将其释放或程序结束；
&emsp;&emsp;5.作用域：描述了`名称`在`文件`的`多大范围`可见!
&emsp;&emsp;6.链接性：描述了`名称`如何在`不同单元`间共享；链接性为外部的名称可在文件间共享，链接性为内部的名称只能由一个文件中的函数共享；
`自动变量作用域：代码块 全局变量：在定义位置到文件结束可用 函数原型中声明的变量：只在参数列表可用 类中声明的成员：作用域为整个类 名称空间中的变量：作用域为整个名称空间`
&emsp;&emsp;7.在C++中关键字`auto`：自动类型推断；`自动变量存储在栈中`
&emsp;&emsp;8.三种静态变量：1.函数内使用static(链接性为无链接) 2.函数外使用static(链接性为内部链接) 3.函数外不使用static(链接性为外部链接) 
&emsp;&emsp;9.使用引用声明`extern`
&emsp;&emsp;10.存储说明符：
auto、register、static、extern、thread_local、`mutable`：被const声明的变量的某个mutable成员可被修改;
&emsp;&emsp;11.限定符:
`const`:全局变量链接性为内部，因此可以放在头文件中
`volatile`:将指针指向某个硬件位置；
&emsp;&emsp;12.函数的存储持续性均为静态，默认链接性为外部链接
&emsp;&emsp;13.可以通过`extern "c" 函数名 `指出使用语言的链接性为C语言；
&emsp;&emsp;14.定位new运算符：可以指定new分配的内存位置；这种分配的内存未必可以使用`delete`释放

## 名称空间
&emsp;&emsp;1.为避免各个不同厂家之间`名称的冲突`
&emsp;&emsp;2.作用域与潜在作用域；
&emsp;&emsp;3.名称空间的使用：
```c
#include<iostream>
namespace Name{
    .....
}
```
&emsp;&emsp;4.名称空间可以是全局的也可以存在于另一个名称空间内；但是不能位于代码段中，默认链接性为外部链接；
&emsp;&emsp;5.通过作用域解析运算符`::`访问名称空间中的名称；
&emsp;&emsp;6.using：1.声明指令;声明名称空间中的变量 2.编译指令：将名称空间中的名称全部导入；
&emsp;&emsp;7.名称空间可以进行嵌套
&emsp;&emsp;8.未命名的名称空间：潜在作用域：从声明到该声明区域的末尾；

# 第十章 对象和类
## 10.1.类的定义
&emsp;&emsp;类是一种用户自定义关于`数据`的`抽象的组合`，它主要描述了程序中数据的基本构成（`数据成员`）以及对数据的访问和操作（`成员函数`或`方法`）;
## 10.2.类的声明
&emsp;&emsp;1.类的声明类似结构声明，可以包括数据成员和函数成员。声明的私有部分，只能由成员函数进行访问。声明的公有部分，可以被使用类对象的程序访问；
&emsp;&emsp;2.类的成员函数声明可以使用`::`作用域解析运算符；
## 10.3.类方法的定义
&emsp;&emsp;1.定义位于类声明的函数（方法）都是内联函数；